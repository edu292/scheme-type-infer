#lang r5rs (#%require simply-scheme)

(define primitive-types
  '((+ . number)
    (- . number)
    (min . number)
    (max . number)
    (first . sentence-or-word)
    (butfirst . sentence-or-word)
    (sentence . sentence-or-word)
    (member? . sentence-or-word)
    (append . list)))

(define (flatmap proc seq)
  (accumulate append (map proc seq)))

(define (assign type values)
  (define (helper value)
    (cond ((symbol? value) (list (list value type)))
          ((list? value) (infer value))
          (else '())))
  (flatmap helper values))

(define (infer exp)
  (if (or (not (list? exp)) (null? exp))
      '()
      (let ((op (car exp))
            (args (cdr exp)))
        (cond ((eq? (car exp) 'quote) '())
              ((assoc op primitive-types)
               => (lambda (type-pair)
                    (let ((type (cdr type-pair)))
                      (assign type args))))
              ((symbol? op)
               (cons (list op 'procedure) (flatmap infer args)))
              (else '())))))
        
(define (conflict? types)
  (define (helper first-type types)
    (cond ((null? types) #f)
          ((not (eq? (car types) first-type)) #t)
          (else (helper first-type (cdr types)))))
  (helper (car types) types))

(define (inferred-types definition)
  (let* ((parameters (cdadr definition))
         (body (cddr definition))
         (types (flatmap infer body)))
    (map (lambda (parameter)
           (let ((type (map cadr (filter (lambda (x) (member? parameter x)) types))))
             (cond ((null? type) (list parameter '?))
                   ((conflict? type) (list parameter 'x))
                   (else (list parameter (car type))))))
         parameters)))